#include <stdio.h>
void main(){
    /*位运算具体应用
    注意：对于逻辑运算，计算机只会看到0和1，非0值均变成1，在进行位运算
          5 && 4 --> 1 && 1 --> 1 & 1 = 1 。而这与直接的位运算完全不同, 5 & 4 = 4
          也有 !4 --> !1 = 0 ，而 ~4 = 3
    一. &   按位与
        1.让某一位或某些位为0 (以下以让低位为0 和 让低3位为0 为例)
            x & 0xFE
            0xFE = 1111 1110
            设x 为 1010 0101
            &后  = 1010 0100
            故0xFE的作用就是将一个数的低位保证为0

            x & ~0111 即 x & ~7
            使得x的低三位保证为0 

        2.取一个数中的一段 (以下以取32位整数中后1/4段为例)
            x & 0xFF
            0xFF = 1111 1111
            设x为int_32的一个数
            x    11110000 00001111 11110000 10101010
            0xFF 00000000 00000000 00000000 11111111
            这样相当于将x的后8个字节输出，十进制下x=4,027,576,490
            此时x只被保留最多255的值(1111 1111)，而现在(1010 1010)即x=170

    二. |   按位或
        1.让某一位或某些位为1 (以下以让低位为1 和 让低3位为1 为例)
            x | 0x01
            0x01 = 0000 0001
            设x 为 1010 0100
            |后  = 1010 0101
            故0x01作用就是将一个数低位保证为1

            x | 0111 即 x | 7
            使得x的低三位保证为1 

        2.将两个数拼接起来
            x1 | x2
            设x1 = 0x00FF , x2 = 0xFF00
            | 后 = 0xFFFF
        
    三. ~   按位取反
        1. ~0 就能获得一个全部位上均为1的数
        2. 常与其他位运算符结合使用,如上述 x | 0111让x低三位为1，那么 x & ~0111让x低三位为0 即获得相对的的结果

    四. ^   按位异或(相异者为1，相同者为0)
        1. 一个数与另一个数异或两次则该数不变 , x^y^y --> x

    五. <<  左移
        i << j
        i中所有位向左移动j个位置，右边空位补0
        注意所有小于int的类型，移位仍当其为int来做，产生的结果是int类型
        x <<= 1 等价于 x *= 2 ,  x <<= n 等价于 x *= pow(2,n)

    六. >>  右移
        i >> j
        i中所有位向右移动j个位置
        注意所有小于int的类型，移位仍当其为int来做，产生的结果是int类型
        对于unsigned类型，左边空位补0
        对于默认的signed类型，左边空位填入原最高位数字(保证符号不变)
        x >>= n 等价于 x /= pow(2,n)



    */
    int a = 100;
    printf("a<<1=%d\n",a<<1);//200  100*2
    printf("a<<2=%d\n",a<<2);//400  100*pow(2,2)

    int b = 0x80000000;//绝对值最大的int负数-2147483648
    printf("b=%d\n",b);
    printf("b>>1=%d\n",b>>1);//-1073741824
    printf("b>>1<<1=%d\n",b>>1<<1);//-2147483648,运算顺序由左到右
    printf("b<<1=%d\n",b<<1);//0，因为二进制来看b是 1000...0000,高位1左移后只剩下0
    unsigned mask = 1 << 31; //1000 0000 .... 0000
    int num = 0x10DEFE;
    for(int times = 1;mask ;mask >>= 1){//每次循环,mask中的1右移一位
        printf("%d",num & mask ? 1:0);//num = 0000 0000 0001 0000 1101 1110 1111 1110
        if(times++ % 4 == 0) printf(" ");
        //用mask来扫描num二进制，随着mask二进制中1的右移，num的二进制也会随着从左往右打出来
    }

}